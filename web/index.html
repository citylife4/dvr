<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
<title>DVR — Live View</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: #111;
    color: #ccc;
    font-family: system-ui, -apple-system, sans-serif;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    user-select: none;
  }

  header {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 8px 16px;
    background: #1a1a1a;
    border-bottom: 1px solid #333;
    flex-shrink: 0;
  }

  header h1 {
    font-size: 16px;
    font-weight: 600;
    color: #eee;
  }

  header a.nav-link {
    color: #888;
    text-decoration: none;
    font-size: 14px;
    padding: 4px 12px;
    border-radius: 4px;
    transition: all 0.2s;
  }
  header a.nav-link:hover { color: #ccc; background: #2a2a2a; }
  header a.nav-link.active { color: #fff; background: #2a6a2a; }

  header .spacer { flex: 1; }

  header .controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  header .controls button {
    background: #2a2a2a;
    border: 1px solid #444;
    color: #ccc;
    padding: 4px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
  }

  header .controls button:hover { background: #3a3a3a; }
  header .controls button.active { background: #1a6b1a; border-color: #2a8a2a; color: #fff; }

  .grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-template-rows: repeat(2, 1fr);
    gap: 2px;
    flex: 1;
    padding: 2px;
    min-height: 0;
    overflow: hidden;
  }

  .grid .channel {
    background: #000;
  }
  
  .grid.single {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr;
  }

  .channel {
    position: relative;
    background: #000;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 2px;
    touch-action: manipulation;
  }

  .channel video {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
  }

  .channel .overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 10px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
    pointer-events: none;
    z-index: 1;
  }

  .channel .label {
    font-size: 13px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  }

  .channel .status {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: 500;
  }

  .status.live { background: #c0392b; color: #fff; }
  .status.connecting { background: #e67e22; color: #fff; }
  .status.error { background: #555; color: #ccc; }

  .channel .message {
    position: absolute;
    color: #666;
    font-size: 14px;
    text-align: center;
  }

  .rec-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #e74c3c;
    color: #fff;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
    display: none;
    z-index: 2;
    animation: pulse-red 1.5s infinite;
  }
  @keyframes pulse-red {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
  }

  .channel.focused {
    grid-column: 1 / -1;
    grid-row: 1 / -1;
  }

  /* When single mode is active, hide non-focused channels */
  .grid.single .channel:not(.focused) { display: none; }

  /* Mobile Tweaks */
  @media (max-width: 600px) {
    header { padding: 8px 10px; gap: 8px; }
    header h1 { font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    header a.nav-link { padding: 4px 8px; font-size: 12px; }
    
    /* Make buttons bigger/easier to tap */
    header .controls button { padding: 6px 12px; font-size: 16px; } 

    /* In portrait, stack channels vertically if not in single mode */ 
    @media (orientation: portrait) {
       .grid:not(.single) {
         grid-template-columns: 1fr;
         grid-template-rows: repeat(4, 1fr);
       }
       /* Hide non-focused channels in single mode on mobile too */
       .grid.single .channel:not(.focused) { display: none; }
    }
  }

  .channel { cursor: pointer; }

  /* Fullscreen tweaks */
  :fullscreen body, :-webkit-full-screen body { height: 100vh; }
</style>
</head>
<body>

<header>
  <h1>&#x1F4F9; DVR Dashboard</h1>
  <a href="/" class="nav-link active">Live View</a>
  <a href="/settings" class="nav-link">Settings</a>
  <a href="/recordings" class="nav-link">Recordings</a>
  <span class="spacer"></span>
  <div class="controls">
    <button id="btn-layout" title="Toggle single/grid view">Grid 2×2</button>
    <button id="btn-fullscreen" title="Fullscreen">⛶</button>
  </div>
</header>

<div class="grid" id="grid">
  <div class="channel" data-ch="0">
    <div class="overlay">
      <span class="label">CH 0</span>
      <span class="status connecting">…</span>
    </div>
    <div class="message">Connecting…</div>
    <div class="rec-indicator">REC</div>
    <video muted autoplay playsinline></video>
  </div>
  <div class="channel" data-ch="1">
    <div class="overlay">
      <span class="label">CH 1</span>
      <span class="status connecting">…</span>
    </div>
    <div class="message">Connecting…</div>
    <div class="rec-indicator">REC</div>
    <video muted autoplay playsinline></video>
  </div>
  <div class="channel" data-ch="2">
    <div class="overlay">
      <span class="label">CH 2</span>
      <span class="status connecting">…</span>
    </div>
    <div class="message">Connecting…</div>
    <div class="rec-indicator">REC</div>
    <video muted autoplay playsinline></video>
  </div>
  <div class="channel" data-ch="3">
    <div class="overlay">
      <span class="label">CH 3</span>
      <span class="status connecting">…</span>
    </div>
    <div class="message">Connecting…</div>
    <div class="rec-indicator">REC</div>
    <video muted autoplay playsinline></video>
  </div>
</div>

<script>
(function () {
  // Auto-detect server host from the page URL
  const HOST = location.hostname || 'localhost';
  const HLS_PORT = 8888;
  const WHEP_PORT = 8889;
  const CHANNELS = [0, 1, 2, 3];
  const RETRY_BASE = 3000;   // initial retry delay ms
  const RETRY_MAX  = 30000;  // max retry delay ms
  const WHEP_TIMEOUT = 10000; // fetch timeout ms
  const STALL_CHECK  = 8000; // watchdog interval ms

  // ── Channel state ──────────────────────────────────
  const channels = {};

  CHANNELS.forEach(ch => {
    const el = document.querySelector(`.channel[data-ch="${ch}"]`);
    channels[ch] = {
      el,
      video: el.querySelector('video'),
      status: el.querySelector('.status'),
      message: el.querySelector('.message'),
      pc: null,
      retryTimer: null,
      retryCount: 0,
      lastFrameTime: 0,
      stallTimer: null,
    };
  });

  function setStatus(ch, state, text) {
    const c = channels[ch];
    c.status.className = 'status ' + state;
    c.status.textContent = text || state;
    c.message.textContent = state === 'live' ? '' :
                            state === 'connecting' ? 'Connecting…' :
                            text || 'Offline';
  }

  // ── WebRTC via WHEP ────────────────────────────────
  async function connectWHEP(ch) {
    const c = channels[ch];
    cleanup(ch);
    setStatus(ch, 'connecting', 'connecting');

    try {
      const pc = new RTCPeerConnection({ iceServers: [] });
      c.pc = pc;

      pc.addTransceiver('video', { direction: 'recvonly' });
      pc.addTransceiver('audio', { direction: 'recvonly' });

      pc.ontrack = (ev) => {
        if (ev.streams && ev.streams[0]) {
          c.video.srcObject = ev.streams[0];
          c.lastFrameTime = Date.now();
          startStallWatchdog(ch);
        }
      };

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'connected') {
          c.retryCount = 0; // reset backoff on success
          setStatus(ch, 'live', 'LIVE');
        } else if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) {
          setStatus(ch, 'error', 'disconnected');
          scheduleRetry(ch);
        }
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // Wait for ICE gathering
      await new Promise(resolve => {
        if (pc.iceGatheringState === 'complete') return resolve();
        pc.onicegatheringstatechange = () => {
          if (pc.iceGatheringState === 'complete') resolve();
        };
        setTimeout(resolve, 2000);
      });

      // Fetch with timeout to avoid hanging on network issues
      const controller = new AbortController();
      const fetchTimer = setTimeout(() => controller.abort(), WHEP_TIMEOUT);

      const whepUrl = `http://${HOST}:${WHEP_PORT}/ch${ch}/whep`;
      const resp = await fetch(whepUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/sdp' },
        body: pc.localDescription.sdp,
        signal: controller.signal,
      });
      clearTimeout(fetchTimer);

      if (!resp.ok) throw new Error(`WHEP ${resp.status}`);

      const answer = await resp.text();
      await pc.setRemoteDescription({ type: 'answer', sdp: answer });

    } catch (err) {
      const msg = err.name === 'AbortError' ? 'timeout' : err.message;
      console.warn(`CH${ch} WHEP failed:`, msg);
      setStatus(ch, 'error', 'retry…');
      scheduleRetry(ch);
    }
  }

  function cleanup(ch) {
    const c = channels[ch];
    if (c.pc) { c.pc.close(); c.pc = null; }
    if (c.retryTimer) { clearTimeout(c.retryTimer); c.retryTimer = null; }
    if (c.stallTimer) { clearInterval(c.stallTimer); c.stallTimer = null; }
    c.video.srcObject = null;
  }

  function scheduleRetry(ch) {
    const c = channels[ch];
    if (c.retryTimer) return;
    // Exponential backoff: 3s, 6s, 12s, 24s, capped at 30s
    const delay = Math.min(RETRY_BASE * Math.pow(2, c.retryCount), RETRY_MAX);
    c.retryCount++;
    console.log(`CH${ch} retry #${c.retryCount} in ${delay}ms`);
    c.retryTimer = setTimeout(() => {
      c.retryTimer = null;
      connectWHEP(ch);
    }, delay);
  }

  // Detect stalled streams (video track alive but no new frames)
  function startStallWatchdog(ch) {
    const c = channels[ch];
    if (c.stallTimer) return;
    c.stallTimer = setInterval(() => {
      if (!c.pc || c.pc.connectionState !== 'connected') return;
      // Check inbound video stats for frame count changes
      c.pc.getStats().then(stats => {
        stats.forEach(report => {
          if (report.type === 'inbound-rtp' && report.kind === 'video') {
            const now = report.framesDecoded || 0;
            if (c._lastFrames !== undefined && now === c._lastFrames) {
              // No new frames in STALL_CHECK interval — reconnect
              console.warn(`CH${ch} stall detected (${now} frames), reconnecting`);
              setStatus(ch, 'error', 'stalled');
              scheduleRetry(ch);
            }
            c._lastFrames = now;
          }
        });
      }).catch(() => {});
    }, STALL_CHECK);
  }
  // ── Recording Status Polling ──────────────────────
  async function updateRecStatus() {
    try {
      const resp = await fetch('/api/recordings/status');
      if (!resp.ok) return;
      const status = await resp.json();
      if (status && Array.isArray(status.active)) {
        status.active.forEach((isActive, idx) => {
          const el = channels[idx].el.querySelector('.rec-indicator');
          if (el) el.style.display = isActive ? 'block' : 'none';
        });
      }
    } catch (e) {
      console.warn('Rec status poll failed', e);
    }
  }

  // ── Layout: grid vs single ─────────────────────────
  const grid = document.getElementById('grid');
  const btnLayout = document.getElementById('btn-layout');
  let singleMode = false;
  let focusedCh = null;

  btnLayout.addEventListener('click', () => {
    if (singleMode) {
      singleMode = false;
      grid.classList.remove('single');
      document.querySelectorAll('.channel').forEach(el => el.classList.remove('focused'));
      btnLayout.textContent = 'Grid 2×2';
      focusedCh = null;
    } else {
      // switch to single mode showing ch0
      enterSingle(0);
    }
  });

  function enterSingle(ch) {
    singleMode = true;
    focusedCh = ch;
    grid.classList.add('single');
    document.querySelectorAll('.channel').forEach(el => {
      el.classList.toggle('focused', parseInt(el.dataset.ch) === ch);
    });
    btnLayout.textContent = `CH ${ch} — Back to Grid`;
  }

  // Click a channel to go single; click again to go back
  document.querySelectorAll('.channel').forEach(el => {
    el.addEventListener('click', () => {
      const ch = parseInt(el.dataset.ch);
      if (singleMode && focusedCh === ch) {
        btnLayout.click();
      } else {
        enterSingle(ch);
      }
    });

    // Prevent double-click zoom interference
    el.addEventListener('dblclick', (e) => { e.preventDefault(); e.stopPropagation(); });
  });

  // ── Fullscreen ─────────────────────────────────────
  document.getElementById('btn-fullscreen').addEventListener('click', () => {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      document.documentElement.requestFullscreen();
    }
  });

  // ── Staggered connect: avoid hammering DVR with all channels at once ──
  const STAGGER_MS = 2000; // 2s between each channel connect

  function staggerConnect(chList) {
    chList.forEach((ch, i) => {
      setTimeout(() => connectWHEP(ch), i * STAGGER_MS);
    });
  }

  // ── Visibility: pause retries when tab hidden, reconnect on show ──
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) return;
    // Tab became visible — reconnect any non-live channels (staggered)
    const dead = CHANNELS.filter(ch => {
      const state = channels[ch].pc && channels[ch].pc.connectionState;
      return state !== 'connected' && state !== 'connecting';
    });
    dead.forEach(ch => { channels[ch].retryCount = 0; cleanup(ch); });
    staggerConnect(dead);
  });

  // ── Start ──────────────────────────────────────────
  staggerConnect(CHANNELS);

  // Start polling recording status
  setInterval(updateRecStatus, 5000);
  updateRecStatus();

})();
</script>
</body>
</html>
